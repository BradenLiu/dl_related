
#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: dev_nb/05b_new_learner.ipynb
from uti.basic_train import *

class CancelTrainException(Exception): pass
class CancelEpochException(Exception): pass
class CancelBatchException(Exception): pass

#abstract class for new callback
class Callback():
    _order = 0
    def _set_learner(self,learn): self.learn = learn
    def begin_fit(self): pass
    def after_fit(self): pass
    def begin_epoch(self): pass
    def begin_validate(self): pass
    def after_epoch(self): pass
    def begin_batch(self): pass
    def after_batch(self): pass
    def after_loss(self): pass
    def begin_backward(self): pass
    def after_backward(self): pass
    def after_step(self): pass
    def after_cancel_train(self): pass
    def after_cancel_epoch(self): pass
    def after_cancel_batch(self): pass


class TrainEvalCallback(Callback):
    def begin_fit(self):
        self.n_epochs, self.n_iters = 0,0

    def begin_epoch(self):
        self.n_epochs = self.learn.epoch #current epoch
        self.learn.model.train()
        self.learn.in_train = True

    def after_batch(self):
        if not self.learn.in_train: return
        self.n_epochs += 1. / self.learn.iters #current epoch step, eg: 1.3 epochs
        self.n_iters +=1

    def begin_validate(self):
        self.learn.model.eval()
        self.learn.in_train = False

class NewLearner():
    def __init__(self, model,opt,loss_func,data,cbs=None):
        self.model,self.opt,self.loss_func,self.data = model,opt,loss_func,data
        self.in_train = False
        self.cbs = []
        self.cbs.append(TrainEvalCallback())
        if cbs:
            for cb in sorted(cbs,key = lambda x: x._order):
                self.cbs.append(cb)

    def one_batch(self,xb,yb):
        try:
            self.xb, self.yb = xb, yb
            for cb in self.cbs: cb.begin_batch()
            self.preds = self.model(self.xb)
            self.loss = self.loss_func(self.preds,self.yb)
            for cb in self.cbs: cb.after_loss()

            if not self.in_train: return

            for cb in self.cbs: cb.begin_backward()
            self.loss.backward()
            for cb in self.cbs: cb.after_backward()
            self.opt.step()
            for cb in self.cbs: cb.after_step()
            self.opt.zero_grad()

        except CancelBatchException:
            for cb in self.cbs: cb.after_cancel_batch()

        finally:
            for cb in self.cbs: cb.after_batch()

    def all_batches(self):
        try:
            for xb,yb in self.dl:
                self.one_batch(xb,yb)
        except CancelEpochException:
            for cb in self.cbs: cb.after_cancel_epoch()


    def fit(self,epochs):
        self.epochs = epochs
        self.iters = len(self.data.train_dl)
        try:
            for cb in self.cbs: cb._set_learner(self)
            for cb in self.cbs: cb.begin_fit()
            for epoch in range(epochs):
                self.epoch = epoch
                self.dl = self.data.train_dl
                for cb in self.cbs: cb.begin_epoch()
                self.all_batches()

                for cb in self.cbs: cb.begin_validate()
                self.dl = self.data.valid_dl
                with torch.no_grad(): self.all_batches()
                for cb in self.cbs: cb.after_epoch()

        except CancelTrainException:
            for cb in self.cbs: cb.after_cancel_train()

        finally:
            for cb in self.cbs: cb.after_fit()
            #self.remove(cb)


class Accuracy(Callback):
    def begin_epoch(self):
        self.train_loss, self.valid_loss = 0, 0
        self.train_acc, self.valid_acc =0, 0
        self.train_bs_count = 0
        self.valid_bs_count = 0

    def accuracy(self, out, yb): return (torch.argmax(out, dim=1)==yb).float().mean()

    def after_loss(self):
        with torch.no_grad():
            bs = self.learn.xb.shape[0]
            if self.learn.in_train:
                self.train_loss += self.learn.loss * bs
                self.train_acc += self.accuracy(self.learn.preds,self.learn.yb) * bs
                self.train_bs_count += bs
            else:
                self.valid_loss += self.learn.loss * bs
                self.valid_acc += self.accuracy(self.learn.preds,self.learn.yb) * bs
                self.valid_bs_count += bs

    def after_epoch(self):
        avg_train_loss = self.train_loss / self.train_bs_count
        avg_valid_loss = self.valid_loss / self.valid_bs_count
        avg_train_acc = self.train_acc / self.train_bs_count
        avg_valid_acc = self.valid_acc / self.valid_bs_count
        print(f'Train: {avg_train_loss}, {avg_train_acc}')
        print(f'Valid: {avg_valid_loss}, {avg_valid_acc}')
        print(' ')



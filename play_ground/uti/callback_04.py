
#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: dev_nb/04_callback.ipynb
from uti.basic_train import *

#abstract class for callbacks
class Callbacks():
    _order = 0
    def begin_fit(self,learn):
        self.learn = learn
        return True
    def after_fit(self): return True
    def begin_epoch(self,epoch):
        self.epoch = epoch
        return True
    def begin_validate(self): return True
    def after_epoch(self): return True
    def begin_batch(self,xb,yb):
        self.xb, self.yb = xb, yb
        return True
    def after_loss(self,loss,preds):
        self.loss = loss
        self.preds = preds
        return True
    def after_backward(self): return True
    def after_step(self): return True

class CallbackHandler():
    def __init__(self,cbs=None):
        self.cbs = cbs if cbs else []

    def begin_fit(self,learn):
        self.learn = learn
        self.in_train = True
        self.learn.stop = False
        if len(self.cbs) is 0: return True #may cause problem
        res = True
        for cb in sorted(self.cbs,key=lambda x: x._order): res = res and cb.begin_fit(learn)
        return res

    def after_fit(self):
        if len(self.cbs) is 0: return True
        res = not self.in_train
        for cb in sorted(self.cbs,key=lambda x: x._order): res = res and cb.after_fit()
        return res

    def begin_epoch(self,epoch):
        self.learn.model.train()
        self.in_train = True
        if len(self.cbs) is 0: return True #may cause problem
        res = True
        for cb in sorted(self.cbs,key=lambda x: x._order): res = res and cb.begin_epoch(epoch)
        return res

    def begin_validate(self):
        self.learn.model.eval()
        self.in_train = False
        if len(self.cbs) is 0: return True #may cause problem
        res = True
        for cb in sorted(self.cbs,key=lambda x: x._order): res = res and cb.begin_validate()
        return res

    def after_epoch(self):
        if len(self.cbs) is 0: return True
        res = True
        for cb in sorted(self.cbs,key=lambda x: x._order): res = res and cb.after_epoch()
        return res

    def begin_batch(self,xb,yb):
        if len(self.cbs) is 0: return True
        res = True
        for cb in sorted(self.cbs,key=lambda x: x._order): res = res and cb.begin_batch(xb,yb)
        return res

    def after_loss(self,loss,preds):
        if len(self.cbs) is 0: return True
        res = True
        for cb in sorted(self.cbs,key=lambda x: x._order): res = res and cb.after_loss(loss,preds)
        return res

    def begin_backward(self):
        res = self.in_train
        return res

    def after_backward(self):
        if len(self.cbs) is 0: return True
        res = True
        for cb in sorted(self.cbs,key=lambda x: x._order): res = res and cb.after_backward()
        return res

    def after_step(self):
        if self.cbs is None: return True
        res = True
        for cb in sorted(self.cbs,key=lambda x: x._order): res = res and cb.after_step()
        return res

    def do_stop(self):
        try: return self.learn.stop
        finally: self.learn.stop = False